Ext.data.JsonP.glu_Viewmodel({"mixedInto":[],"tagname":"class","extends":null,"alternateClassNames":[],"inheritdoc":null,"parentMixins":[],"singleton":false,"statics":{"css_mixin":[],"cfg":[],"method":[],"property":[],"event":[],"css_var":[]},"requires":[],"mixins":[],"code_type":"assignment","inheritable":false,"meta":{},"members":{"css_mixin":[],"cfg":[],"method":[{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"ajax","id":"method-ajax"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"confirm","id":"method-confirm"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"doClose","id":"method-doClose"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"fireEvent","id":"method-fireEvent"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"get","id":"method-get"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"localize","id":"method-localize"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"message","id":"method-message"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"model","id":"method-model"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"on","id":"method-on"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"open","id":"method-open"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"set","id":"method-set"},{"tagname":"method","owner":"glu.Viewmodel","meta":{},"name":"setRaw","id":"method-setRaw"}],"event":[],"property":[],"css_var":[]},"uses":[],"subclasses":[],"name":"glu.Viewmodel","aliases":{},"superclasses":[],"component":false,"html_meta":{},"id":"class-glu.Viewmodel","html":"<div><pre class=\"hierarchy\"><h4>Files</h4><div class='dependency'><a href='source/viewmodel.html#glu-Viewmodel' target='_blank'>viewmodel.js</a></div></pre><div class='doc-contents'><p>The view model is the \"common sense\" representation of application state and behavior. A 'root' view model represents\nthe application as a whole (or the module if you are a sub-app within a 'portal'), while other view models represent\nvarious screens (tabs, etc.) or areas of a screen.</p>\n\n<h2>Defining and creating a view model</h2>\n\n<p>A view model can be defined and instantiated on the fly from within a view model :</p>\n\n<pre><code> var model = this.model ({\n     status: 'OK'\n });\n //or for a dialog\n this.open ({\n     status: 'OK'\n });\n</code></pre>\n\n<p>or it can be defined first (with namespace) and then referenced later through the 'mtype' property (as long\nas you are in the same namespace):</p>\n\n<pre><code> glu.defModel('example.main', {\n     status : 'OK'\n });\n var vm = this.model ({\n     mtype : 'main'\n });\n</code></pre>\n\n<p>A view model can also be defined 'inline' within a containing view model using an 'mtype' property of 'viewmodel'</p>\n\n<pre><code> glu.defModel('example.main', {\n     detail : {\n         mtype : 'viewmodel',\n         myProp : 'A'\n     }\n });\n</code></pre>\n\n<p>or simply by reference</p>\n\n<pre><code> glu.defModel('example.subscreen', {\n     myProp : 'A'\n });\n glu.defModel('example.main', {\n     detail : {\n         mtype : 'subscreen'\n     }\n });\n</code></pre>\n\n<p>Referenced view models are fully parameterizable, so you can initialize any of the values with overrides:</p>\n\n<pre><code> glu.defModel('example.main', {\n     status : 'OK'\n });\n //...later...\n var vm = this.model({\n     mtype : 'main',\n     status : 'BAD'\n );\n</code></pre>\n\n<p>A 'root' view model can be instantiated by one of several entry points, but most typically by setting it as the 'app':</p>\n\n<pre><code> glu.app('example.main');\n</code></pre>\n\n<p>or</p>\n\n<pre><code> glu.app({\n     mtype :'example.main',\n     //optional parameters...\n });\n</code></pre>\n\n<p>or it can be included as a subpanel of an already existing application panel:</p>\n\n<pre><code> //...\n items : [{\n     xtype: 'glupanel',\n     viewmodelConfig : {\n         mtype : 'main',\n         //optional parameters...\n     }\n }],\n //...\n</code></pre>\n\n<p>or (usually just for testing) you can start one with a fully qualified namespace</p>\n\n<pre><code> var vm = glu.model('example.main');\n</code></pre>\n\n<h2>View model parts</h2>\n\n<p>The view model is composed of several distinct parts that represent your application state and behavior:</p>\n\n<ul>\n<li> Properties: Hold states that various parts of the screen can be in. Usually correspond to things that the user can set\n (like the contents of a text field, or the currently active tab, or which rows of a grid are selected).</li>\n<li> Formulas: Calculated properties that respond to changes in properties or other formulas. By their nature, they are\n read-only so they typically represent the app 'responding' to user interaction. Glu will analyze the formula and keep it\n updated when input properties change.</li>\n<li> Submodels: Contains various subscreens and lists of subscreens (glu is for full applications so view models are always\n in a hierarchy with a single root). There is also a special 'parentVM' property to find any view model's container.</li>\n<li> Commands: Actions that the user can take that aren't represented by simple properties. For instance, a save button or\n hitting the 'close window' indicator.</li>\n<li> Reactors: Rules that are triggered on property / formula changes so you don't have to put all of your side-effects\n into the property setter. For instance, refreshing the grid when any of several filters change. A formula is really a\n special type of reactor where the action is setting a single property; if it's more complicated, use a reactor.</li>\n</ul>\n\n\n<h2>Example</h2>\n\n<pre><code> glu.model({\n     //PROPERTIES\n     classroomName : 'Science',\n     status : 'OK',\n\n     //FORMULAS\n     classroomNameIsValid : function() { return this.classroomName !== '';}\n     statusIsEnabled : function(){ return this.classroomNameIsValid;}\n\n     //SUBMODELS\n     students : {\n         mtype : 'list'\n         items : [{\n             mtype : 'student',\n             firstName : 'Mike'\n         }]\n     }\n\n     //COMMANDS\n     clear : function() {\n         this.set('firstName','');\n         this.set('status','OK');\n     }\n\n     //REACTORS\n     when_status_is_not_ok_then_fetch_problem_detail : {\n         on : ['statusChanged'],\n         action : function() {\n             if (this.status!=='OK'){\n                 //fetch problem detail\n             }\n         }\n     }\n });\n</code></pre>\n\n<h2>Properties</h2>\n\n<p>Properties are declared simply by adding a property to the config object. The initial value will be whatever is provided.</p>\n\n<pre><code> foo : 'we are foo'\n</code></pre>\n\n<p>Properties are accessed through the 'get' and 'set' methods. You can also read properties by simply reading the backing property directly:</p>\n\n<pre><code> this.foo\n</code></pre>\n\n<p>As long as the property is bound or a reactive formulas, the value will always be current with UI state so a getter\nis not strictly necessary. It is a matter of preference whether you access the property directly or call</p>\n\n<pre><code> get ('foo')\n</code></pre>\n\n<p>to keep the get behavior encapsulated within the viewmodel.\nTo change get/set behavior (not usually recommended), you can manually add get/set overrides by using the convention:</p>\n\n<pre><code> getFoo : function(){ return...}\n setFoo : function(value) {\n    this.setRaw('foo',value);\n }\n</code></pre>\n\n<p>Calls to get() and set() will honor these overrides.</p>\n\n<p>In the future, we may provide either automatic getter/setters [getFoo() / setFoo('value')] and/or\nKnockout-style getters/setters [foo()/foo('value')] if there is demand (we have experimented with both but always fallen back\nto our old ways)</p>\n\n<h2>Formulas</h2>\n\n<p>Formulas are read-only properties that respond to changes in other properties. To declare a formula, put a '$' at\nthe end of the name (this won't become part of its name but is just a flag) and then supply a function that returns\na value:</p>\n\n<pre><code> saveIsEnabled$: function(){return this.isValid &amp;&amp; this.isDirty;}\n</code></pre>\n\n<p>GluJS will scan the function and find property change events to listen for and so will automatically keep up to date with a minimum\nof recalculation. In the example above,\nif (and only if) the 'isValid' or 'isDirty' properties change, it will update the value of 'saveIsEnabled'.\nFormulas can also be chained: in the example above both 'isValid' and 'isDirty' are actually other formulas!</p>\n\n<h4>IsValid</h4>\n\n<p>There is one bit of magic-by-convention with formulas. If you name a formula such that it ends with 'IsValid', it will automatically\ncontribute to a global 'isValid' property on the view model. When all such formulas return true, then the global 'isValid' will\nalso be true.</p>\n\n<h2>Submodels</h2>\n\n<p>GluJS is a framework for quickly developing real applications with complex navigation and screens. Very often you'll want to split your\nview models in parts. The initial example above has a list of 'student' view models. This list could correspond on the screen to\na set of items in a mobile list or a set of tabs. This is just one of the built-in UI composition patterns within gluJS.\nSubmodels are indicated by using the 'mtype' property within a nested object.</p>\n\n<h2>Commands</h2>\n\n<p>Whenever the user needs to take an action that isn't necessarily as simple as updating a property - especially when it involves\nan Ajax call - then that is a command.\nTypical commands are 'save', 'refresh', etc. They are declared simply by providing a function:</p>\n\n<pre><code> save : function(){\n     //...\n }\n</code></pre>\n\n<p>Very often, behavior that could be a command can really be expressed as properties. For instance, the\n'collapse' button on a panel could be a 'collapse' command. But it also could be more simply\nmodeled by a property:</p>\n\n<pre><code> detailIsExpanded : true\n</code></pre>\n\n<p>Now you can get both collapse and expand in a single property and a single binding - and you have some state you can use\nfor other behavior (like in a formula).\nWhenever possible, see if what you're trying to do can be reduced to a property and go with that.</p>\n\n<h2>Reactors</h2>\n\n<p>The reactor pattern is simply a shortcut to managing \"event observers\". It's a powerful way to reduce code clutter and break\nout different UI behavior as \"rules\". For instance, if you want to refresh the grid whenever any one of five different properties\nchange, you could call 'refreshgrid' in each of those property setters. Or, you could simply state the following:</p>\n\n<pre><code> When_a_grid_related_property_changes_Then_refresh_grid : {\n     on : ['propertyAChanged','propertyBChanged','propertyCChanged','propertyDChanged','propertyEChanged'],\n     action : function(){\n         this.refreshStudents();\n     }\n }\n</code></pre>\n\n<p>Later when you realize that you'd like to load only on an explicit refresh or just need to temporarily suppress the behavior for\ndebugging, you can just comment it out and \"switch off\" the behavior in one place.\nWhile this is an entirely optional pattern, it is a natural and powerful fit for building reactive UIs.</p>\n\n<h2>Convenience methods</h2>\n\n<p>There are a number of convenience methods that are commonly used within a view model. Use them\ninstead of the matching ones on the 'glu' object because they\n*    pass in the local namespace\n*    set the scope of any callback to the viewmodel (so 'this' always refers to the view model)\n*    automatically create parent/child associations where appropriate\n*    are automatically mocked as needed by the simulation/testing framework just on that view model without breaking core 'glu' for other view models.</p>\n\n<p>The methods are as follows:</p>\n\n<ul>\n<li>localize</li>\n<li>confirm</li>\n<li>message</li>\n<li>open</li>\n<li>ajax</li>\n<li>model</li>\n</ul>\n\n</div><div class='members'><div class='members-section'><div class='definedBy'>Defined By</div><h3 class='members-title icon-method'>Methods</h3><div class='subsection'><div id='method-ajax' class='member first-child not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-ajax' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-ajax' class='name expandable'>ajax</a>( <span class='pre'>Object config</span> )</div><div class='description'><div class='short'>Makes a normal Ajax call through the underlying ajax provider. ...</div><div class='long'><p>Makes a normal Ajax call through the underlying ajax provider. The scope is automatically set to the view model.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : Object<div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-confirm' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-confirm' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-confirm' class='name expandable'>confirm</a>( <span class='pre'>Object title, Object message, Object fn, Object scope</span> ) : *</div><div class='description'><div class='short'>Shortcut for a confirmation dialog with a callback. ...</div><div class='long'><p>Shortcut for a confirmation dialog with a callback.\nThe scope of the callback will be the view model.\nIn test mode will be replaced with a jasmine spy with an additional function called respond\nso that you can simulate a response. Simply return the name of the button that you want to be simulated:</p>\n\n<pre><code> vm.confirm.respond('ok')\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>title</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>message</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>fn</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>scope</span> : Object<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-doClose' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-doClose' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-doClose' class='name expandable'>doClose</a>( <span class='pre'></span> )</div><div class='description'><div class='short'>Performs the underlying close operation on this view model. ...</div><div class='long'><p>Performs the underlying close operation on this view model. Of course this only makes sense where the viewmodel\ncorresponds to either a floating dialog, a screen on a mobile stack, or an item in a container (tabpanel, card, etc.)</p>\n</div></div></div><div id='method-fireEvent' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-fireEvent' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-fireEvent' class='name expandable'>fireEvent</a>( <span class='pre'></span> )</div><div class='description'><div class='short'>Fires off an event to any observers. ...</div><div class='long'><p>Fires off an event to any observers.\nThere is usually little reason to call this directly, unless you are doing a broadcast pattern to children\nin which some of them may opt in and others don't. In other cases (and within the viewmodel), it is usually\nbetter just to invoke methods directly for clarity.</p>\n</div></div></div><div id='method-get' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-get' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-get' class='name expandable'>get</a>( <span class='pre'>Object propName</span> ) : *</div><div class='description'><div class='short'>Returns the value of a property. ...</div><div class='long'><p>Returns the value of a property.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>propName</span> : Object<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-localize' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-localize' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-localize' class='name expandable'>localize</a>( <span class='pre'>Object key, Object params</span> ) : *</div><div class='description'><div class='short'>Localizes based on the provided lookup key. ...</div><div class='long'><p>Localizes based on the provided lookup key.\nThe view model will be passed in and the default localizer will look for the key in a matching locale namespace\nfirst and then go to the root. So for a viewmodel called 'student' and a key called 'grade', both of these would work:</p>\n\n<pre><code> example.locale = {\n     grade : 'Student Grade'\n };\n example.locale = {\n     student : {\n         grade : 'Student Grade'\n     }\n };\n</code></pre>\n\n<p>Localization keys can also include substitution parameters. If a parameter set is not included in the call, it will be\nprovided off of the view model. So if there was a 'firstName' on the view model, this shortcut would work:</p>\n\n<pre><code> example.locale = {\n     grade : 'Student Grade for {firstName} {lastName}'\n }\n</code></pre>\n\n<p>The default localizer can be overridden with a call to glu.setLocalizer if the localization pattern is already\nset in stone on an existing project.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>key</span> : Object<div class='sub-desc'><p>The look up key</p>\n</div></li><li><span class='pre'>params</span> : Object<div class='sub-desc'><p>The values to be used when substituting within the locale string</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-message' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-message' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-message' class='name expandable'>message</a>( <span class='pre'>Object title, Object message, Object fn, Object scope</span> ) : *</div><div class='description'><div class='short'>Shortcut for a quick message dialog. ...</div><div class='long'><p>Shortcut for a quick message dialog.\nIn test mode will be replaced with a jasmine spy.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>title</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>message</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>fn</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>scope</span> : Object<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-model' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-model' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-model' class='name expandable'>model</a>( <span class='pre'>Object config</span> ) : *</div><div class='description'><div class='short'>Creates a new child model for this view model. ...</div><div class='long'><p>Creates a new child model for this view model. The child model will not affect any screen behavior until\nit is added to a list that is bound to a view that displays child components. For instance, to add a new student\ntab you could do the following:</p>\n\n<pre><code> addStudentScreen : function(id) {\n     var student = this.model ({mtype:'student', id:di});\n     student.init(); //load the backing data\n     this.studentScreens.add(student);\n }\n</code></pre>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : Object<div class='sub-desc'>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-on' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-on' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-on' class='name expandable'>on</a>( <span class='pre'>Object eventName, Object handler, Object scope</span> )</div><div class='description'><div class='short'>Adds a listener for a view model event with a default scope of the view model itself\nThe formula and reactor patterns...</div><div class='long'><p>Adds a listener for a view model event with a default scope of the view model itself\nThe formula and reactor patterns (see above) means there is little reason to use this directly within a viewmodel.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>eventName</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>handler</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>scope</span> : Object<div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-open' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-open' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-open' class='name expandable'>open</a>( <span class='pre'>Object config</span> ) : *</div><div class='description'><div class='short'>Opens a view model as a popup (usually modal) dialog or pushes a screen on to a mobile navigation stack. ...</div><div class='long'><p>Opens a view model as a popup (usually modal) dialog or pushes a screen on to a mobile navigation stack.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>config</span> : Object<div class='sub-desc'><p>A normal config block that you would pass into glu.model, only in this case it also displays the view model in a window.\nIn test mode it instantiates the new view model but does not instantiate the view.</p>\n</div></li></ul><h3 class='pa'>Returns</h3><ul><li><span class='pre'>*</span><div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-set' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-set' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-set' class='name expandable'>set</a>( <span class='pre'>Object propName, Object value</span> )</div><div class='description'><div class='short'>Sets the value of a property. ...</div><div class='long'><p>Sets the value of a property. If there is a custom setter defined, it will use that instead.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>propName</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>value</span> : Object<div class='sub-desc'>\n</div></li></ul></div></div></div><div id='method-setRaw' class='member  not-inherited'><a href='#' class='side expandable'><span>&nbsp;</span></a><div class='title'><div class='meta'><span class='defined-in' rel='glu.Viewmodel'>glu.Viewmodel</span><br/><a href='source/viewmodel.html#glu-Viewmodel-method-setRaw' target='_blank' class='view-source'>view source</a></div><a href='#!/api/glu.Viewmodel-method-setRaw' class='name expandable'>setRaw</a>( <span class='pre'>Object propName, Object value</span> )</div><div class='description'><div class='short'>Sets the raw value of a property and bypasses any custom setter. ...</div><div class='long'><p>Sets the raw value of a property and bypasses any custom setter. This is usually used within\nthe custom setter itself to set the underlying property after any preprocessing.</p>\n<h3 class=\"pa\">Parameters</h3><ul><li><span class='pre'>propName</span> : Object<div class='sub-desc'>\n</div></li><li><span class='pre'>value</span> : Object<div class='sub-desc'>\n</div></li></ul></div></div></div></div></div></div></div>","files":[{"href":"viewmodel.html#glu-Viewmodel","filename":"viewmodel.js"}]});