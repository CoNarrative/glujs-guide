<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*
 * Copyright (C) 2012 by CoNarrative
 */
<span id='glu-extjs-adapters-combo'>/**
</span> * @class glu.extjs.adapters.combo
 * @author Mike Gai
 * @extends glu.extjs.adapters.field
 *
 * The combo box is usually bound by value (by default the backing Model) and to a store.
 *
 * Note : This adapter eliminates race conditions caused by the value being set
 * before the backing store is loaded. When the store changes (a la the backing
 * data arrives), it will check to see if the value is now present and then set the combo
 * box accordingly.
 */

/*
 */
glu.regAdapter('combo',{
    extend : 'field',

<span id='glu-extjs-adapters-combo-cfg-store'>    /**
</span>     * @cfg {Ext.data.Store} store
     * The store for this grid.
     *
     * *One-time binding*
     *
     * **Convention**: @{*itemList*}
     */
    beforeCreate:function (config, viewmodel) {
        if (!config.store) return;
        if (config.store.gluTweaked == true) return;
        config.store.gluTweaked = true;
        var evtName = Ext.getVersion().major &gt; 3 ? 'datachanged' : 'load';
        config.store.on(evtName, function () {
            var control = Ext.getCmp(config.id);
            if(!control) return;
            control.setValue(control.targetValue);
        });
    },
    afterCreate:function (control, viewmodel) {
        //Solves a race condition in which the initial value is set before the backing store has been loaded
        //does not attempt to solve later race conditions with stores reloading
        if (!control.valueField) return;
        // var r = control.findRecord(control.valueField, control.value);
        // if(r) {
        // //reset the value one last time just in case the callback has already happened
        // control.setValue(control.value);
        // return;
        // }
        control.setValueActual = control.setValue;
        control.setValue = function (value) {
            this.targetValue = value;
            this.setValueActual(value);
        };
        control.setValue(control.value);
        //there is no record, so wait until load
        // control.store.on('load',function(){
        // control.setValue(control.value);
        // //control.store.un('load'); //stop listening for load event
        // });                
    },
    valueBindings:{
        eventName:'select',
        eventConverter:function (control, record, idx) {
            return control.getValue();
        }

    }
});
</pre>
</body>
</html>
